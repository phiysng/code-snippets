# 使用一个变量标记来退出一个线程

`libuv`在它的主事件循环中使用一个变量来标记事件循环是否应该立即终止
但是`libuv`是一个单线程的事件循环库,可以使用一个普通的变量来标记状态

TODO:
在多线程中,需要使用`mutex`或原子变量的手段来保证读写的原子性
同时还要考虑内存的可见性问题(一个线程对于内存的修改对于另外一个线程可能是不可见的)

C++11引入的内存模型
- Relaxed 
	- 同一个线程中所有操作保证顺序，在多线程环境中顺序是任意安排的
- Release / Acquire
	- 一个 Release 操作会阻止当前线程中其他的读写操作被重排到这个操作之后
	   （当然了，前提是你的代码顺序也是这样）。
		而 Acquire 操作会阻止当前线程中其他的读写操作被重排到这个操作之前
- Consume
	- 这通常与 Release 配对使用，但它只限制有依赖的变量操作 详见cppreference

- Seq-Cst
	- 顺序一致模型，它是 memory_order_acq_rel 的加强版，它能保证所有变量和所有原子操作都同步，
	  顺序均一致。它会使用 Memory Barrier （内存屏障， 在 x86 中对应 mfence 指令）
	  来保证多个线程间的内存可见性。而且，这是 x86 架构的默认内存模型。

--------------------------------------
合理使用 Memory Order 配合 CAS 操作能实现运行效率更高的 lock-free 代码，但是对于大多数开发者来说，使用 Mutex 来进行 data sharing 和线程同步可能是更好的选择